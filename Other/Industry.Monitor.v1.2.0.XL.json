{"slots":{"-5":{"name":"library","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}}},"handlers":[{"key":1,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":";(function()\nlocal a={}local b=0;function library.addEventHandlers(c)if not c or c.onEvent and c.triggerEvent then return false end;b=b+1;a[b]=c;local d,e,f='table','function','thread'if d~=type(c)then error('You can only add event handlers to table objects!')end;local g={}local function h(c)local i=type(c)return e==i or d==i and h(getmetatable(c).__call)or f==i end;c.onEvent=function(self,j,k,l)if not h(k)then error('Event handler must be a function, a callable object or a thread!')end;l=l or self;if d~=type(l)then error('The value of self must be a table!')end;if not g[j]then g[j]={_=0}end;local m=f==type(k)and function(...)coroutine.resume(k,...)end or k;local k=g[j]local n=k._+1;k[n]={m,l}k._=n;return n end;c.clearEvent=function(self,j,o)if g[j]and g[j][o]then g[j][o]=nil end end;c.clearAllEvents=function(self)g={}end;c.triggerEvent=function(self,j,...)local p=g[j]if p then for q=1,p._ do local k=p[q]if k then k[1](k[2],...)end end end end;return true end;function library.clearAllEventHandlers()for q=1,b do local c=a[q]if c and c.clearAllEvents then c:clearAllEvents()end end end\nend)()"},{"key":2,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":";(function()\nlocal a=DULibrary or{}function a.getLinks(b,c)local d={}if not b then b={}end;for e,f in pairs(unit.getOutPlugs())do local g=unit[f.name]if'table'==type(g)and'function'==type(g.getClass)then local h=true;for i,j in pairs(b)do if not('function'==type(g[i])and j==g[i]():sub(1,#j))then h=false;break end end;if h then if c then table.insert(d,g)else d[f.name]=g end end end end;return d end;function a.getLinksByClass(k,c)return a.getLinks({getClass=k},c)end;function a.getLinkByClass(k)return a.getLinksByClass(k,true)[1]end;function a.getCoreUnit()return a.getLinkByClass('CoreUnit')end;function a.getLinkByName(l)local m=a.getCoreUnit()if not m then error('getLinkByName requires a linked CoreUnit to work')end;local d=a.getLinks()for n,o in pairs(d)do if l==m.getElementNameById(o.getLocalId())then return o end end end\nend)()"},{"key":3,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":"package.preload['@wolfe-labs/IndustryMonitor:tasks.lua']=(function()\n--[[\n  Coroutine-based Backkground Tasks API for Dual Universe\n  by Wolfe Labs\n  Version: 0.1.0\n]]\n\n-- How much CPU time we're allocating for background tasks, defaults to 20%\nlocal MAX_CPU_TIME = 0.20\n\n-- This is a list of all our tasks\nlocal _tasks = {}\n\n-- This is just a counter to calculate the next task index\nlocal _tasks_index = 0\n\n-- This is a pointer to our current task\nlocal _current_task = nil\nlocal _current_task_index = nil\nlocal _current_task_count = 0\n\n-- Helper function to assert we're inside a task\nlocal function task_assert()\n  if not _current_task then\n    error('This function must be invoked from inside a running task!')\n  end\nend\n\n-- Helper function to exit a running task\nlocal function task_exit()\n  _tasks[_current_task_index] = nil\n  coroutine.yield()\nend\n\n-- Helper function to rate-limit inside a task\nlocal yield_limit = system.getInstructionLimit() * MAX_CPU_TIME\nlocal function task_cpu_limit()\n  if _current_task then\n    if system.getInstructionCount() >= (yield_limit / math.max(_current_task_count, 1)) then\n      coroutine.yield()\n    end\n  end\nend\n\n-- Helper function that does task processing\nlocal function task_work()\n  -- Gets an updated task count\n  _current_task_count = 0\n  for _ in pairs(_tasks) do\n    _current_task_count = _current_task_count + 1\n  end\n\n  -- Processes each of the tasks\n  for task_index, task in pairs(_tasks) do\n    _current_task = task\n    _current_task_index = task_index\n    coroutine.resume(task.coroutine)\n  end\n\n  -- Clears existing data after done\n  _current_task = nil\n  _current_task_index = nil\nend\n\n---@class Task\nlocal Task = {}\n\n--- Creates a new task\nfunction Task.new(runner)\n  -- Calculates the new id for our task\n  _tasks_index = _tasks_index + 1\n  local task_id = 0 + _tasks_index\n\n  -- Those will store our task callbacks and event handlers\n  local resolve_callbacks = {}\n  local error_handlers = {}\n\n  -- Initializes the task in memory\n  _tasks[task_id] = {\n    coroutine = coroutine.create(function()\n      local status, ret = pcall(runner)\n      if status then\n        Task.resolve(ret)\n      else\n        Task.reject(ret)\n      end\n    end),\n    resolve_callbacks = resolve_callbacks,\n    error_handlers = error_handlers,\n  }\n\n  -- Pointer to our other pointer\n  local self = nil\n\n  -- Creates our Task Pointer API\n  ---@class TaskPointer\n  local TaskPointer = {}\n\n  function TaskPointer.id()\n    return task_id\n  end\n\n  function TaskPointer.next(callback)\n    table.insert(resolve_callbacks, callback)\n    return self\n  end\n\n  function TaskPointer.catch(handler)\n    table.insert(error_handlers, handler)\n    return self\n  end\n\n  function TaskPointer.completed()\n    return _tasks[task_id] == nil\n  end\n\n  -- Assigns our API\n  self = setmetatable({}, {\n    __index = TaskPointer,\n  })\n\n  return self\nend\n\n--- Resolves a task with an optional return value\nfunction Task.resolve(return_value)\n  task_assert()\n\n  -- Invokes each of the callbacks\n  for _, callback in pairs(_current_task.resolve_callbacks) do\n    callback(return_value)\n  end\n\n  -- Deletes task and stops execution\n  task_exit()\nend\n\n--- Rejects (reports an error) the current task\nfunction Task.reject(error_message)\n  task_assert()\n\n  -- Special case when no error handlers are present\n  if #_current_task.error_handlers == 0 then\n    system.print(('Unhandled error on task #%d: %s'):format(_current_task_index, tostring(error_message)))\n  end\n\n  -- Invokes each of the error handlers\n  for _, handler in pairs(_current_task.error_handlers) do\n    handler(error_message)\n  end\n\n  -- Deletes task and stops execution\n  task_exit()\nend\n\n--- Iterates over an object using a task (can be used outside tasks, too)\nfunction Task.iterate(object)  \n  -- Gets a list of all keys\n  local keys = {}\n  for key in pairs(object) do\n    task_cpu_limit()\n    \n    table.insert(keys, key)\n  end\n  table.sort(keys)\n  \n  -- Now, we can actually iterate over that temporary table\n  local index = 0\n  return function()\n    task_cpu_limit()\n    \n    -- Increments local iterator, returns value if any\n    index = index + 1\n    if keys[index] then\n      return object[keys[index]], keys[index]\n    end\n\n    -- This only happens if we don't have any more items\n    return nil\n  end\nend\n\n--- This makes tasks work, make sure you call this from your system.onUpdate event!\nfunction Task.work()\n  task_work()\nend\n\n-- Special case for DU Lua CLI users\nif system.onEvent then\n  system:onEvent('onUpdate', task_work)\n  Task.work = function() end\nend\n\n-- Returs our public API\nreturn Task\nend)\npackage.preload['@wolfe-labs/IndustryMonitor:industry_monitor.lua']=(function()\n-- Public options exposed to Dual Universe\nRefresh_Interval=5--export: How often to refresh the screen, in seconds\nRange_Start=1--export: Only starts displaying after a certain number of industry\nInclude_3D_Printers=true--export: \nInclude_Assembly_Lines=true--export: \nInclude_Chemical_Industries=true--export: \nInclude_Electronics_Industries=true--export: \nInclude_Glass_Furnaces=true--export: \nInclude_Honeycomb_Refiners=true--export: \nInclude_Metalwork_Industries=true--export: \nInclude_Recyclers=true--export: \nInclude_Refiners=true--export: \nInclude_Smelters=true--export: \nInclude_Transfer_Units=true--export: \nShow_Tier_1=true--export: \nShow_Tier_2=true--export: \nShow_Tier_3=true--export: \nShow_Tier_4=true--export: \nShow_Industry_Name=false--export: Shows industry name instead of item name\nStuck_After_X_Hours_Jammed=false--export: Marks units as potentially stuck after being jammed for X hours\nStuck_Detection_Hours=36--export: How many hours in jammed status until an unit is considered stuck\n\nRange_Start = math.max(1, Range_Start)\n\nlocal json = require('json')\nlocal task = require('@wolfe-labs/IndustryMonitor:tasks.lua')\n\nlocal version_string = '1.2.0'\n\nlocal stuck_detection_seconds = 3600 * Stuck_Detection_Hours\n\nlocal function embed_json(data)\n  return (\"data = require('json').decode('%s')\")\n    :format(\n      json.encode(data)\n        :gsub('\\\\', '\\\\\\\\')\n        :gsub('\\'', '\\\\\\'')\n    )\nend\n\nlocal function round(value, decimals, roundUp)\n  local multiplier = 10 ^ decimals\n  return ((roundUp and math.ceil) or math.floor)(value * multiplier) / multiplier\nend\n\nlocal function formatSeconds(time)\n  local parts = {}\n\n  if time >= 86400 then\n    local days = math.floor(time / 86400)\n    table.insert(parts, days .. 'd')\n    time = time - 86400 * days\n  end\n\n  if time >= 3600 then\n    local hours = math.floor(time / 3600)\n    table.insert(parts, hours .. 'h')\n    time = time - 3600 * hours\n  end\n\n  if time >= 60 then\n    local minutes = math.floor(time / 60)\n    table.insert(parts, minutes .. 'm')\n    time = time - 60 * minutes\n  end\n  \n  if time > 0 then\n    table.insert(parts, time .. 's')\n  end\n\n  return table.concat(parts, ' ')\nend\n\n---@param screens table<number,Screen> The screens where everything is going to be rendered\n---@param page_size number How many lines are supported per page by the render script\n---@param ui_render_script string The render script\nlocal function IndustryMonitor(screens, page_size, ui_render_script)\n  -- Hide widget\n  unit.hideWidget()\n\n  -- Ensures a core is linked\n  local core = library.getCoreUnit()\n  if not core then\n    print('ERROR: Core Unit not connected!')\n    return unit.exit()\n  end\n\n  -- Ensures at least one screen is linked\n  if #screens == 0 then\n    print('ERROR: No screen not connected!')\n    return unit.exit()\n  end\n\n  -- List of included tiers\n  local industry_tiers_allowed = {\n    [1] = Show_Tier_1,\n    [2] = Show_Tier_2,\n    [3] = Show_Tier_3,\n    [4] = Show_Tier_4,\n  }\n\n  -- General definitions\n  local industry_states = {\n    [0] = 'Loading',\n    [1] = 'Stopped',\n    [2] = 'Running',\n    [3] = 'No Ingredients',\n    [4] = 'Output Full',\n    [5] = 'No Output',\n    [6] = 'Pending',\n    [7] = 'Missing',\n  }\n\n  -- Creates industry groups\n  local industry_group_search = {}\n  if Include_3D_Printers then industry_group_search['3D Printer'] = '3D Printers' end\n  if Include_Transfer_Units then industry_group_search['Transfer Unit'] = 'Transfer Units' end\n  if Include_Assembly_Lines then industry_group_search['Assembly Line'] = 'Assembly Lines' end\n  if Include_Chemical_Industries then industry_group_search['Chemical Industry'] = 'Chemical Industries' end\n  if Include_Refiners then industry_group_search['Refiner'] = 'Refiners' end\n  if Include_Electronics_Industries then industry_group_search['Electronics Industry'] = 'Electronics Industries' end\n  if Include_Smelters then industry_group_search['Smelter'] = 'Smelters' end\n  if Include_Recyclers then industry_group_search['Recycler'] = 'Recyclers' end\n  if Include_Glass_Furnaces then industry_group_search['Glass Furnace'] = 'Glass Furnaces' end\n  if Include_Honeycomb_Refiners then industry_group_search['Honeycomb Refiner'] = 'Honeycomb Refineries' end\n  if Include_Metalwork_Industries then industry_group_search['Metalwork Industry'] = 'Metalwork Industries' end\n\n  -- How many industry we can keep in memory\n  local headers_max = 0\n  for _ in pairs(industry_group_search) do\n    headers_max = headers_max + 1\n  end\n  local industry_max = #screens * page_size - headers_max\n\n  local industry_groups = {}\n  for _, name in pairs(industry_group_search) do\n    industry_group_search[_] = _\n    industry_groups[_] = {\n      name = name,\n      items = {\n        [1] = {},\n        [2] = {},\n        [3] = {},\n        [4] = {},\n        [5] = {},\n      },\n    }\n  end\n\n  -- Utility to merge arrays\n  local function array_merge(array, ...)\n    local arrays = {...}\n    local result = { table.unpack(array) }\n    for _, array in pairs(arrays) do\n      for _, value in pairs(array) do\n        table.insert(result, value)\n      end\n    end\n    return result\n  end\n\n  -- Utility to merge objects\n  local function object_merge(target, ...)\n    local arrays = {...}\n    for _, object in pairs(arrays) do\n      for key, value in pairs(object) do\n        target[key] = value\n      end\n    end\n    return target\n  end\n\n  -- Utility to get world position\n  local function local_to_world(pos)\n    return vec3(construct.getWorldPosition())\n      + vec3(construct.getWorldRight()) * pos.x\n      + vec3(construct.getWorldForward()) * pos.y\n      + vec3(construct.getWorldUp()) * pos.z\n  end\n\n  -- Utility to get a destination ::pos string\n  local function get_waypoint(pos)\n    return ('::pos{0,0,%.4f,%.4f,%.4f}'):format(pos.x, pos.y, pos.z)\n  end\n\n  -- Utility to set a destination\n  local function set_waypoint(pos)\n    system.setWaypoint(('string' == type(pos) and pos) or get_waypoint(pos))\n  end\n\n  -- Utility to split a command in spaces\n  local function split(str)\n    local tokens = {}\n    for token in string.gmatch(str, \"[^%s]+\") do\n      table.insert(tokens, token)\n    end\n    return tokens\n  end\n\n  -- Utility to print an item name\n  local function item_name(item)\n    local name = item\n    local size = ''\n    if 'table' == type(item) then\n      name = item.displayName\n      size = item.size or ''\n    end\n\n    return ('%s %s'):format(\n      name\n        -- Abbreviates some names\n        :gsub('Atmospheric', 'Atmo.')\n        :gsub('Expanded', 'Exp.')\n        :gsub('Uncommon', 'Unc.')\n        :gsub('Advanced', 'Adv.'),\n      size:upper()\n    )\n      -- Trims empty spaces at end of name\n      :gsub('^%s+', '')\n      :gsub('%s+$', '')\n  end\n\n  -- Gets items by id with caching\n  local item_cache = {}\n  local function get_item(id)\n    if not item_cache[id] then\n      item_cache[id] = system.getItem(id)\n    end\n    return item_cache[id]\n  end\n\n  -- Gets the main recipe of something\n  local function get_main_recipe(id)\n    local recipes = system.getRecipes(id)\n\n    local largest_recipe = { 0, nil }\n    for recipe in task.iterate(recipes) do\n      for product in task.iterate(recipe.products) do\n        if product.id == id then\n          if product.quantity > largest_recipe[1] then\n            largest_recipe = { product.quantity, recipe }\n          end\n        end\n      end\n    end\n\n    return largest_recipe[2]\n  end\n\n  -- Gets industry base information\n  local industry_ids = {}\n  local industry_numbers = {}\n  local function get_industry_information(local_id)\n    -- If the industry unit does not exist, stop here\n    if not industry_numbers[local_id] then\n      return nil\n    end\n\n    -- Let's have a cache of industry info to speed-up bootstrap\n    local item_id = core.getElementItemIdById(local_id)\n\n    -- Let's extract current industry info\n    local item = get_item(item_id)\n\n    -- Gets custom industry unit name\n    local industry_custom_name = core.getElementNameById(local_id)\n    if industry_custom_name == ('%s [%d]'):format(item.displayNameWithSize, local_id) then\n      industry_custom_name = nil\n    end\n\n    -- Let's get the industry group\n    local group = nil\n    for group_id, search in task.iterate(industry_group_search) do\n      if nil ~= item.displayName:lower():find(search:lower()) and (search:lower() ~= 'refiner' or nil == item.displayName:lower():find('honeycomb')) then\n        group = group_id\n        break\n      end\n    end\n    \n    -- Returns final information\n    return {\n      id = local_id,\n      num = industry_numbers[local_id],\n      name = item.displayName,\n      group_id = group,\n      custom_name = industry_custom_name,\n      is_transfer_unit = 'number' == type(item.displayName:lower():find('transfer unit')),\n      tier = item.tier,\n    }\n  end\n\n  -- Loads all present industry in construct\n  local industry_count = 0\n  local industry_range_last = 0\n  local industry_total = 0\n  local industry = {}\n  local task_industry = task.new(function()\n    local ids = core.getElementIdList()\n    table.sort(ids)\n\n    local limit_reached = false\n    for local_id in task.iterate(ids) do\n      if 'Industry' == core.getElementClassById(local_id):sub(1, 8) then\n        -- Generates a identifier\n        industry_count = industry_count + 1\n        industry_ids[industry_count] = local_id\n        industry_numbers[local_id] = industry_count\n\n        -- Only does extra processing inside our \"processing window\"\n        if not limit_reached then\n          -- Let's have a cache of industry info to speed-up bootstrap\n          local item_id = core.getElementItemIdById(local_id)\n\n          -- Let's extract current industry info\n          local item = get_item(item_id)\n\n          -- Counts up until limit_reached == true, this will determine our max number\n          industry_range_last = industry_range_last + 1\n\n          -- Fetches the unit's information\n          local industry_data = get_industry_information(local_id)\n\n          -- If we have a valid group, let's assign it\n          if industry_data.group_id then\n            if industry_count >= Range_Start and industry_tiers_allowed[item.tier] then\n              industry_total = industry_total + 1 \n\n              industry[industry_count] = industry_data\n              table.insert(industry_groups[industry_data.group_id].items[item.tier], industry_data)\n            end\n          end\n\n          -- Handles limit of industry across all screens\n          if industry_total >= industry_max then\n            limit_reached = true\n          end\n        end\n      end\n    end\n  end)\n\n  -- Gets industry status\n  local function get_industry_unit_status(industry_number, industry_unit)\n    -- Loads industry unit information (if none is provided)\n    industry_unit = industry_unit or industry[industry_number] or get_industry_information(industry_ids[industry_number])\n\n    -- Safety check\n    if not industry_unit then\n      return nil\n    end\n\n    local info = core.getElementIndustryInfoById(industry_unit.id)\n    local industry_status = {}\n\n    -- Produced item information\n    local main_product = info.currentProducts[1]\n    local main_product_item = nil\n    if main_product then\n      main_product_item = get_item(main_product.id)\n    end\n    local itemName = (main_product_item and item_name(main_product_item)) or 'No item selected'\n    industry_status.item = itemName\n    industry_status.item_id = (main_product_item and main_product_item.id) or nil\n\n    -- I/O information\n    local inputs = 0\n    local outputs = 0\n    local output_element_id = nil\n    for plug in task.iterate(core.getElementInPlugsById(industry_unit.id)) do\n      if plug.elementId then\n        inputs = inputs + 1\n      end\n    end\n    for plug in task.iterate(core.getElementOutPlugsById(industry_unit.id)) do\n      if plug.elementId then\n        outputs = outputs + 1\n        output_element_id = plug.elementId\n      end\n    end\n\n    -- For oxygen or hydrogen, override inputs to 1 so we don't see errors\n    if itemName:lower() == 'pure hydrogen' or itemName:lower() == 'pure oxygen' then\n      inputs = 1\n    end\n\n    industry_status.num_inputs = inputs\n    industry_status.num_outputs = outputs\n\n    -- Schematic information\n    local schematic = nil\n    if #info.requiredSchematicIds > 0 then\n      schematic = get_item(info.requiredSchematicIds[1]).displayName\n    end\n    industry_status.schematic = schematic\n\n    -- Basic informations\n    industry_status.state = industry_states[info.state]\n    industry_status.state_code = info.state\n    industry_status.is_stuck = false\n\n    -- Single batch has been completed?\n    local is_completed = false\n    if industry_status.state_code == 1 and info and info.batchesRequested > 0 and info.batchesRemaining < 1 then\n      is_completed = true\n    end\n    industry_status.completed = (is_completed and info.unitsProduced) or false\n\n    -- Maintain: off, X amount, forever\n    industry_status.maintain = false\n    if info.maintainProductAmount > 0 then\n      industry_status.maintain = info.maintainProductAmount\n\n      -- Handles special case when industry gets \"stuck\" on \"pending\"\n      if info.state ~= 1 and (info.state == 6 or (Stuck_After_X_Hours_Jammed and info.remainingTime < -stuck_detection_seconds)) then\n        -- For cases where the \"output is full\" we'll set a lower target mass, to accurately check it\n        local target_mass_multiplier = 1.0\n        if info.state == 4 then\n          target_mass_multiplier = 0.5\n        end\n\n        -- This is our target maintain quantity, the reason we subtract 1 here is for cases where we're with output full, it shouldn't be a big deal\n        local target_maintain = info.maintainProductAmount\n        if target_maintain > 1 then\n          target_maintain = target_maintain - 1\n        end\n\n        -- Estimates how much mass there should be in that container\n        local output_mass_empty = get_item(core.getElementItemIdById(output_element_id)).unitMass\n        local output_mass_current = core.getElementMassById(output_element_id)\n        local target_mass = output_mass_empty + (main_product_item.unitMass * target_maintain) * 0.75 * target_mass_multiplier\n\n        -- Fixes rounding errors\n        output_mass_current = round(output_mass_current, 2, true)\n        target_mass = round(target_mass, 2)\n        \n        -- Handles possibly stuck states\n        if target_mass - output_mass_current > 0.0000001 then\n          industry_status.is_stuck = true\n        end\n      end\n    elseif 1 ~= industry_status.state_code and info.unitsProduced > 0 and info.batchesRemaining < 0 then\n      industry_status.maintain = true\n    end\n\n    -- Handles edge case where maintain is set to 0\n    if 'number' == type(industry_status.maintain) and industry_status.maintain < 1 then\n      industry_status.is_stuck = true\n    end\n\n    -- Single Batch\n    industry_status.single_batch = false\n    if false == industry_status.maintain and (1 ~= industry_status.state_code or industry_status.completed) then\n      industry_status.single_batch = info.unitsProduced + math.max(info.batchesRemaining, 0)\n    end\n\n    -- Special state handling when no inputs or no outputs are provided\n    if industry_status.is_stuck then\n      industry_status.state_code = 5\n    elseif outputs == 0 and industry_status.state_code ~= 5 then\n      industry_status.state = 'No Linked Output'\n      industry_status.state_code = 3\n    elseif inputs == 0 then\n      industry_status.state = 'No Linked Input'\n      industry_status.state_code = 3\n    end\n\n    -- Creates a proper label string\n    local label = ('%s: %s'):format(industry_status.state, industry_status.item)\n    if industry_status.is_stuck then\n      -- Batches completed\n      label = ('Stuck %s'):format(industry_status.state)\n    elseif nil ~= industry_status.completed and false ~= industry_status.completed then\n      -- Batches completed\n      label = ('Ready: %dx %s'):format(industry_status.completed, industry_status.item)\n    elseif industry_status.state_code == 7 then\n      -- Missing schematic\n      label = ('%s: %s'):format(industry_status.state, industry_status.schematic)\n    elseif (industry_status.state_code == 4 or industry_status.state_code == 6) and 'number' == type(industry_status.maintain) then\n      -- Maintain full, fixed amount\n      label = ('Maintain: %dx %s'):format(math.floor(industry_status.maintain), industry_status.item)\n    elseif industry_status.state_code == 4 and true == industry_status.maintain then\n      -- Maintain full, forever\n      label = ('Maintain: %s'):format(industry_status.item)\n    end\n    industry_status.state_label = label\n\n    return industry_status, industry_unit\n  end\n\n  -- Gets industry providing input materials\n  local function get_industry_provider_ids(industry_number)\n    local industry_unit = industry[industry_number] or get_industry_information(industry_ids[industry_number])\n\n    -- Safety check\n    if not industry_unit then\n      return nil\n    end\n\n    -- Gets unit current status (for the schematic)\n    local industry_status = get_industry_unit_status(industry_number)\n\n    -- This is out output\n    local industry_providers = {}\n    local container_providers = {}\n\n    -- Gets schematic information\n    if industry_status.item_id then\n      -- Fills in the ingredients\n      for recipe in task.iterate(system.getRecipes(industry_status.item_id)) do\n        if industry_unit.is_transfer_unit then\n          for product in task.iterate(recipe.products) do\n            industry_providers[product.id] = {}\n          end\n        else\n          for ingredient in task.iterate(recipe.ingredients) do\n            industry_providers[ingredient.id] = {}\n          end\n        end\n      end\n\n      -- Loops through each of the connected containers\n      for plug_current_industry in task.iterate(core.getElementInPlugsById(industry_unit.id)) do\n        if plug_current_industry.elementId then\n          -- Saves the current container\n          table.insert(container_providers, plug_current_industry.elementId)\n\n          -- Loop through each of the inputs for each container\n          for plug_container in task.iterate(core.getElementInPlugsById(plug_current_industry.elementId)) do\n            -- Check if we have a valid industry connected\n            if plug_container.elementId and industry_numbers[plug_container.elementId] then\n              -- Pull the information from that industry unit\n              local provider_unit = get_industry_information(plug_container.elementId)\n              local provider_status = get_industry_unit_status(provider_unit.num)\n\n              -- Maps the industry\n              if provider_status.item_id and industry_providers[provider_status.item_id] then\n                table.insert(industry_providers[provider_status.item_id], provider_unit.num)\n              end\n            end\n          end\n        end\n      end\n    end\n\n    -- Clean-up\n    for providers, ingredient_id in task.iterate(industry_providers) do\n      if #providers == 0 then\n        industry_providers[ingredient_id] = nil\n      end\n    end\n\n    return industry_providers, container_providers\n  end\n\n  -- This function will be called when the above task gets completed, it will set-up update and rendering tasks, along with any commands\n  task_industry.next(function()\n    local industry_number_digits = string.len(industry_count)\n\n    -- Setup text-mode\n    local text_output = {}\n    local is_activated_via_plug = unit.getSignalIn('in') == 1\n\n    -- Main render loop\n    local task_render = nil\n    local function is_rendering()\n      return task_render and not task_render.completed()\n    end\n    local function render()\n      if not is_rendering() then\n        task_render = task.new(function()\n          -- Detects text mode\n          local is_text_mode = is_activated_via_plug and #text_output > 0\n\n          -- Creates main listing, sorts by tier\n          local entries = {}\n          if is_text_mode then\n            entries = text_output\n          else\n            for group in task.iterate(industry_groups) do\n              local items = {}\n\n              -- Adds title\n              table.insert(items, group.name)\n\n              -- Adds items\n              for tier_items in task.iterate(group.items) do\n                for industry_unit in task.iterate(tier_items) do\n                  local is_running = industry_unit.state_code == 2 or industry_unit.state == 6\n\n                  -- Should we show the industry unit name instead of the item?\n                  local display_name = industry_unit.item or ''\n                  if Show_Industry_Name and industry_unit.custom_name then\n                    display_name = industry_unit.custom_name\n                  end\n\n                  table.insert(items, {\n                    industry_unit.num,\n                    industry_unit.tier,\n                    is_running,\n                    industry_unit.state_code,\n                    industry_unit.state_label,\n                    display_name,\n                    industry_unit.completed,\n                    industry_unit.schematic or '',\n                    industry_unit.maintain,\n                    industry_unit.is_stuck,\n                  })\n                end\n              end\n\n              -- If we have any items (other than the category heading) let's add it to the render queue\n              if #items > 1 then\n                entries = array_merge(entries, items)\n              end\n            end\n          end\n\n          -- Create pagination\n          local pages = {}\n          local current_page = 0\n          local current_page_size = page_size\n          for entry in task.iterate(entries) do\n            if current_page_size == page_size then\n              current_page = current_page + 1\n              current_page_size = 0\n              pages[current_page] = {}\n            end\n            current_page_size = current_page_size + 1\n            \n            table.insert(pages[current_page], entry)\n          end\n        \n          -- Goes through each of the pages and renders their respective pages\n          for screen, page_number in task.iterate(screens) do\n            if pages[page_number] then\n              screen.setRenderScript(\n                table.concat({\n                  embed_json({\n                    digits = industry_number_digits,\n                    rows = pages[page_number] or {},\n                    text_mode = is_text_mode,\n                  }),\n                  ui_render_script,\n                }, '\\n')\n              )\n              screen.activate()\n            else\n              screen.setRenderScript('')\n              screen.deactivate()\n            end\n          end\n        end)\n      end\n    end\n    \n    -- Text-mode toggles\n    local function print(...)\n      local strings = {}\n      for _, value in pairs({ ... }) do\n        table.insert(strings, tostring(value))\n      end\n\n      if is_activated_via_plug then\n        table.insert(text_output, table.concat(strings, ' '))\n\n        if not is_rendering() then\n          render()\n        end\n      else\n        system.print(table.concat(strings, ' '))\n      end\n    end\n    local function printf(fmt, ...)\n      print(fmt:format(...))\n    end\n\n    -- When in text-mode, hijack the system.print so we can output to the screen\n    if is_activated_via_plug then\n      system.print = print\n    end\n\n    -- Setup commands\n    local commands = {}\n\n    function commands.about()\n      print('')\n      if is_activated_via_plug then\n        printf('System version: v%s', version_string)\n      end\n      printf('Registered %d industry units out of %d max', industry_total, industry_max)\n      printf('Showing range %d to %d, out of %d total units on construct', Range_Start, industry_range_last, industry_count)\n      print('You can customize this range with the Range Start option')\n    end\n\n    function commands.help()\n      print('')\n      print('Commands:')\n      print(' - help: prints list of commands')\n      print(' - about: shows information about the script and current range')\n      print(' - find [code]: sets waypoint to industry unit with matching code')\n      print(' - find_id [id]: same as \"find\" but using element id')\n      print(' - info [code]: views information and status for an industry unit')\n      print(' - info_id [id]: same as \"info\" but using element id')\n      print(' - trace [code]: runs complete error check on an industry unit')\n      print(' - error_check: re-runs the error check above')\n\n      if is_activated_via_plug then\n        print(' - clear: clears text mode and goes back to industry view')\n      end\n    end\n\n    function commands.find(industry_number)\n      industry_number = tonumber(industry_number)\n      local industry_unit = industry[industry_number]\n\n      print('')\n      if industry_unit then\n        local pos = vec3(core.getElementPositionById(industry_unit.id))\n          -- The position will always be on the bottom of the industry unit, so let's position it 0.5m into it to make it easier to find\n          + vec3(core.getElementUpById(industry_unit.id)) * 0.5\n\n        local wp = get_waypoint(local_to_world(pos))\n        set_waypoint(wp)\n\n        printf('Found industry unit #%d:', industry_number)\n        printf(' - Element ID: %d', industry_unit.id)\n        printf(' - Element Type: %s', core.getElementDisplayNameById(industry_unit.id))\n        printf(' - Element Name: %s', industry_unit.custom_name or core.getElementNameById(industry_unit.id))\n        printf(' - Position: %s', wp)\n        print('Set waypoint to requested industry unit!')\n      else\n        print('Industry unit not found!')\n      end\n    end\n    \n    function commands.find_id(industry_id)\n      return commands.find(industry_numbers[tonumber(industry_id)])\n    end\n\n    function commands.error_check()\n      return task.new(function()\n        local errors = {}\n\n        local missing_schematics = {}\n        local is_missing_schematics = false\n\n        local missing_inputs = {}\n        local missing_outputs = {}\n        local stuck = {}\n        for industry_unit in task.iterate(industry) do\n          if industry_unit.state_code == 7 then\n            is_missing_schematics = true\n            missing_schematics[industry_unit.schematic] = true\n          end\n\n          if industry_unit.num_inputs == 0 then\n            table.insert(missing_inputs, industry_unit)\n          end\n          if industry_unit.num_outputs == 0 then\n            table.insert(missing_outputs, industry_unit)\n          end\n\n          if industry_unit.is_stuck then\n            table.insert(stuck, industry_unit)\n          end\n        end\n\n        -- Adds missing schematics\n        if is_missing_schematics then\n          local err = {'Missing Schematics:'}\n          for _, schematic in task.iterate(missing_schematics) do\n            table.insert(err, ' - ' .. schematic)\n          end\n          table.insert(errors, err)\n        end\n\n        -- Adds missing inputs or outputs\n        if #missing_inputs > 0 then\n          local err = {'Inputs not connected:'}\n          for industry_unit in task.iterate(missing_inputs) do\n            table.insert(err, (' - [%d] %s'):format(industry_unit.num, industry_unit.name))\n          end\n          table.insert(errors, err)\n        end\n        if #missing_outputs > 0 then\n          local err = {'Outputs not connected:'}\n          for industry_unit in task.iterate(missing_outputs) do\n            table.insert(err, (' - [%d] %s'):format(industry_unit.num, industry_unit.name))\n          end\n          table.insert(errors, err)\n        end\n\n        -- Adds stuck machines\n        if #stuck > 0 then\n          local err = {'Possibly stuck industry:'}\n          for industry_unit in task.iterate(stuck) do\n            table.insert(err, (' - [%d] %s'):format(industry_unit.num, industry_unit.name))\n          end\n          table.insert(errors, err)\n        end\n        \n        -- Renders errors\n        if #errors > 0 then\n          for error in task.iterate(errors) do\n            print('')\n            \n            if 'string' == type(error) then\n              print(error)\n            else\n              for line in task.iterate(error) do\n                print(line)\n              end\n            end\n          end\n        else\n          print('')\n          print('No errors have been found!')\n        end\n      end)\n    end\n\n    function commands.info(industry_number)\n      task.new(function()\n        industry_number = tonumber(industry_number)\n        \n        local industry_status, industry_unit = get_industry_unit_status(industry_number)\n\n        print('')\n        if industry_status then\n          printf('Status for industry #%d:', industry_number)\n          printf(' - Element ID: %d', industry_unit.id)\n          printf(' - Element Type: %s', core.getElementDisplayNameById(industry_unit.id))\n          printf(' - Element Name: %s', industry_unit.custom_name or core.getElementNameById(industry_unit.id))\n\n          -- Prints batch type\n          if industry_status.maintain == true then\n            print(' - Batch Type: Run Indefinitely')\n          elseif 'number' == type(industry_status.maintain) then\n            printf(' - Batch Type: Maintain', industry_status.maintain)\n          elseif industry_status.single_batch then\n            printf(' - Batch Type: Single Batch', industry_status.single_batch)\n          end\n\n          printf(' = %s', industry_status.state_label)\n        else\n          print('Industry unit not found!')\n        end\n      end)\n    end\n    \n    function commands.info_id(industry_id)\n      return commands.info(industry_numbers[tonumber(industry_id)])\n    end\n\n    function commands.trace(industry_number)\n      task.new(function()\n        industry_number = tonumber(industry_number)\n\n        local industry_status, industry_unit = get_industry_unit_status(industry_number)\n        \n        print('')\n        if industry_status then\n          printf('Checking industry for errors: #%d', industry_number)\n\n          local function test_industry_status(industry_status)\n            -- Test for some common status codes\n            local code = industry_status.state_code\n            if industry_status.is_stuck then\n              return false, 'This industry unit seems stuck!'\n            elseif code == 7 then\n              return false, 'This industry unit is missing schematics!'\n            elseif industry_status.num_inputs == 0 then\n              return false, 'This industry unit is missing inputs!'\n            elseif industry_status.num_outputs == 0 or code == 5 then\n              return false, 'This industry unit is missing outputs!'\n            elseif not industry_status.item_id then\n              return false, 'This industry unit has no selected item!'\n            elseif code == 1 then\n              return false, 'This industry unit is stopped!'\n            elseif code == 2 or industry_status.state_code == 4 or code == 6 then\n              return true, 'This industry unit seems to be okay!'\n            end\n\n            -- Might require further investigation\n            return nil\n          end\n\n          -- This function recurses into an unit's providers to find for errors\n          local function find_upstream_issues(industry_unit, errors)\n            local industry_status = get_industry_unit_status(industry_unit.num)\n            local industry_providers, container_providers = get_industry_provider_ids(industry_unit.num)\n            local provider_count = 0\n            local ingredient_ids = {}\n            for providers, ingredient_id in task.iterate(industry_providers) do\n              -- Marks ingredient as present\n              ingredient_ids[ingredient_id] = true\n\n              for provider_id in task.iterate(providers) do\n                provider_count = provider_count + 1\n\n                local provider_status, provider_unit = get_industry_unit_status(provider_id)\n                local result, message = test_industry_status(provider_status)\n                \n                -- Checks if something failed\n                if not result then\n                  if 'boolean' == type(result) then\n                    -- Checks for easy fixes\n                    table.insert(errors, ('%s [%d]: %s (makes %s)'):format(item_name(provider_unit.name), provider_unit.num, message, item_name(provider_status.item)))\n                  else\n                    -- We'll need to recurse further\n                    find_upstream_issues(provider_unit, errors)\n                  end\n                end\n              end\n            end\n\n            if provider_count == 0 and #container_providers == 0 then\n              local industry_status = get_industry_unit_status(industry_unit.num)\n              table.insert(errors, ('%s [%d]: has no providers (%s)'):format(item_name(industry_unit.name), industry_unit.num, industry_status.state_label))\n            elseif industry_status.item_id ~= nil then\n              local recipe = get_main_recipe(industry_status.item_id)\n              for ingredient in task.iterate(recipe.ingredients) do\n                if not ingredient_ids[ingredient.id] then\n                  table.insert(errors, ('%s [%d]: missing ingredient (%s)'):format(item_name(industry_unit.name), industry_unit.num, item_name(get_item(ingredient.id))))\n                end\n              end\n            end\n          end\n\n          -- Tests current industry\n          local result, message = test_industry_status(industry_status)\n\n          -- We have a simple fix\n          if 'boolean' == type(result) then\n            if result then\n              return print(message)\n            else\n              print('Found issue with the industry unit:')\n              printf(' - %s', message)\n              return\n            end\n          end\n\n          -- No simple fix, let's use recursion (this will happen when ingredients are missing)\n          print('Industry unit has the following status:')\n          printf(' - %s', industry_status.state_label)\n          print('Checking upstream industry for clues...')\n          local errors = {}\n          find_upstream_issues(industry_unit, errors)\n\n          -- Prints all errors\n          if #errors > 0 then\n            print('Found possible causes for the issue:')\n            for error in task.iterate(errors) do\n              printf(' - %s', error)\n            end\n          else\n            print('Found no issues with upstream industry!')\n          end\n        else\n          print('Industry unit not found!')\n        end\n      end)\n    end\n\n    function commands.clear(skip_render)\n      text_output = {}\n\n      if not skip_render then\n        render()\n      end\n    end\n\n    -- This runs only after first status update\n    local is_first_update = true\n    local function first_update()\n      if not is_first_update or is_activated_via_plug then\n        return\n      end\n      is_first_update = false\n\n      commands.about()\n      commands.error_check()\n        .next(commands.help)\n    end\n\n    -- Main update loop\n    local task_update = nil\n    local function update()\n      if (not task_update) or task_update.completed() then\n        task_update = task.new(function()\n          -- Updates industry information\n          for industry_unit, industry_number in task.iterate(industry) do\n            object_merge(industry[industry_number], get_industry_unit_status(industry_number, industry_unit))\n          end\n        end).next(render).next(first_update)\n      end\n    end\n\n    -- Setup our refresh loop\n    unit:onEvent('onTimer', update)\n    unit.setTimer('refresh', Refresh_Interval)\n    update()\n\n    -- Monitors chat for commands\n    system:onEvent('onInputText', function(_, text)\n      local parsed = split(text)\n      local command = parsed[1]\n      \n      -- Parses arguments\n      local arguments = {}\n      for i = 2, #parsed do\n        table.insert(arguments, parsed[i])\n      end\n\n      -- Invokes the command\n      if 'function' == type(commands[command]) then\n        -- Special handler for text mode\n        if is_activated_via_plug then\n          commands.clear(true)\n          printf('> %s', text)\n        end\n\n        commands[command](table.unpack(arguments))\n      end\n    end)\n  end)\n\n  return {\n    version = version_string,\n  }\nend\n\nreturn IndustryMonitor\nend)"},{"key":4,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":"library.addEventHandlers(library)\nlibrary.addEventHandlers(system)\nlibrary.addEventHandlers(player)\nlibrary.addEventHandlers(construct)\nlibrary.addEventHandlers(unit)"},{"key":5,"filter":{"slotKey":-4,"signature":"onActionStart(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionStart',action)"},{"key":6,"filter":{"slotKey":-4,"signature":"onActionLoop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionLoop',action)"},{"key":7,"filter":{"slotKey":-4,"signature":"onActionStop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionStop',action)"},{"key":8,"filter":{"slotKey":-4,"signature":"onUpdate()","args":[]},"code":"system:triggerEvent('onUpdate')"},{"key":9,"filter":{"slotKey":-4,"signature":"onFlush()","args":[]},"code":"system:triggerEvent('onFlush')"},{"key":10,"filter":{"slotKey":-4,"signature":"onInputText(text)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onInputText',text)"},{"key":11,"filter":{"slotKey":-4,"signature":"onCameraChanged(mode)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onCameraChanged',mode)"},{"key":12,"filter":{"slotKey":-3,"signature":"onParentChanged(oldId,newId)","args":[{"variable":"*"},{"variable":"*"}]},"code":"player:triggerEvent('onParentChanged',oldId,newId)"},{"key":13,"filter":{"slotKey":-2,"signature":"onDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onDocked',id)"},{"key":14,"filter":{"slotKey":-2,"signature":"onUndocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onUndocked',id)"},{"key":15,"filter":{"slotKey":-2,"signature":"onPlayerBoarded(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onPlayerBoarded',id)"},{"key":16,"filter":{"slotKey":-2,"signature":"onVRStationEntered(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onVRStationEntered',id)"},{"key":17,"filter":{"slotKey":-2,"signature":"onConstructDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onConstructDocked',id)"},{"key":18,"filter":{"slotKey":-2,"signature":"onPvPTimer(active)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onPvPTimer',active)"},{"key":19,"filter":{"slotKey":-1,"signature":"onStop()","args":[]},"code":"unit:triggerEvent('onStop')"},{"key":20,"filter":{"slotKey":-1,"signature":"onTimer(timerId)","args":[{"variable":"*"}]},"code":"unit:triggerEvent('onTimer',timerId)"},{"key":21,"filter":{"slotKey":-1,"signature":"onStart()","args":[]},"code":"\n\nlocal IndustryMonitor = require('@wolfe-labs/IndustryMonitor:industry_monitor.lua')\n\n-- Gets connected screens\nlocal screens = library.getLinksByClass('Screen', true) ---@type table<number,Screen>\n\n-- How many industry per page we have\nlocal page_size = 204\n\n-- The render script we'll be using\nlocal render_script = 'local is_text_mode = data.text_mode == true\\n\\nlocal margin = 8\\nlocal text_size = 10\\nlocal text_padding = 2\\nlocal line_size = text_size + text_padding\\n\\nlocal font_number = loadFont(\\'RobotoMono\\', text_size)\\nlocal font_name = loadFont(\\'Oxanium-Medium\\', text_size)\\nlocal font_title = loadFont(\\'BankGothic\\', text_size)\\n\\nlocal title_color = { 1, 1, 1 }\\n\\nlocal width, height = getResolution()\\nlocal columns = (is_text_mode and 1) or 4\\nlocal column_size = (width - margin) / columns\\nlocal column_items = math.floor(height / line_size)\\n\\nlocal layers = {}\\nfor i = 0, columns do\\n  layers[i] = createLayer()\\n  setLayerClipRect(layers[i], i * column_size, 0, column_size, height)\\n  setDefaultTextAlign(layers[i], AlignH_Left, AlignV_Top)\\nend\\n\\nlocal tier_colors = {\\n  { 0.75, 0.75, 0.75 },\\n  { 0, 0.8, 0 },\\n  { 0, 0.6, 1 },\\n  { 0.8, 0, 0.8 },\\n  { 0.8, 0.6, 0 },\\n}\\n\\nlocal state_colors = {\\n  [0] = { 0.10, 0.10, 0.10 }, -- Loading\\n  [1] = { 0.15, 0.15, 0.15 }, -- Stopped\\n  [2] = { 0.08, 0.20, 0.05 }, -- Running\\n  [3] = { 1.00, 0.50, 0.00 }, -- Missing ingredient\\n  [4] = { 1.00, 0.50, 0.00 }, -- Output full\\n  [5] = { 1.00, 0.00, 0.00 }, -- No output\\n  [6] = { 0.05, 0.15, 0.20 }, -- Pending\\n  [7] = { 1.00, 0.00, 0.00 }, -- Missing schematics\\n}\\n\\nlocal function color(c, i, a)\\n  i = i or 1\\n  a = a or 1\\n  return c[1] * i, c[2] * i, c[3] * i, a\\nend\\n\\nfunction pad(number, digits)\\n  return string.rep(\\'0\\', digits - string.len(number)) .. number\\nend\\n\\nfunction render(item, layer, x, y)\\n  if \\'string\\' == type(item) then\\n    render_title(item, layer, x, y)\\n  else\\n    render_item(item, layer, x, y)\\n  end\\nend\\n\\nfunction render_title(title, layer, x, y)\\n  if not is_text_mode then\\n    setNextStrokeColor(layer, color(title_color))\\n    setNextStrokeWidth(layer, 1)\\n    addLine(layer, x - text_padding, y + text_size, x + column_size, y + text_size)\\n  end\\n\\n  setNextFillColor(layer, color(title_color))\\n  addText(layer, font_title, title, x + text_padding, y + text_padding / 2)\\nend\\n\\nlocal number_digits = data.digits or 0\\nfunction render_item(item, layer, x, y)\\n  local num = pad(item[1], number_digits)\\n  local tier = item[2]\\n  local tier_color = tier_colors[tier + 1]\\n  local is_running = item[3]\\n  local state = item[4]\\n  local state_color = state_colors[state] or state_colors[1]\\n  local state_label = item[5]\\n  local item_label = item[6]\\n  local quantity_completed = item[7]\\n  local schematic = item[8]\\n  local maintain = item[9]\\n  local is_stuck = item[10]\\n\\n  local label = (\\'%s: %s\\'):format(state_label, item_label)\\n  if is_stuck then\\n    -- Stuck\\n    state_color = { 1, 0, 0.5 }\\n  elseif nil ~= quantity_completed and false ~= quantity_completed then\\n    -- Batches completed\\n    state_color = { 0, 1, 0.75 }\\n    label = (\\'Ready: %dx %s\\'):format(quantity_completed, item_label)\\n  elseif state == 7 then\\n    -- Missing schematic\\n    label = (\\'%s: %s\\'):format(state_label, schematic)\\n  elseif (state == 4 or state == 6) and \\'number\\' == type(maintain) then\\n    -- Maintain full, fixed amount\\n    state_color = state_colors[6]\\n    label = (\\'Maintain: %dx %s\\'):format(math.floor(maintain), item_label)\\n  elseif state == 4 and true == maintain then\\n    -- Maintain full, forever\\n    state_color = state_colors[6]\\n    label = (\\'Maintain: %s\\'):format(item_label)\\n  end\\n\\n  local num_width = getTextBounds(font_number, num)\\n  \\n  setNextFillColor(layer, color(tier_color, 0.3))\\n  addText(layer, font_number, num, x, y)\\n\\n  setNextFillColor(layer, color(state_color))\\n  addText(layer, font_name, label, x + num_width + text_padding, y)\\nend\\n\\n-- Special settings for text mode\\nif is_text_mode then\\n  text_size = 14\\n  text_padding = 4\\n  line_size = text_size + text_padding\\n  \\n  font_title = loadFont(\\'FiraMono\\', text_size)\\n  title_color = { 0.75, 0.75, 0.75 }\\nend\\n\\n-- Main loop\\nfor _, item in pairs(data.rows or {}) do\\n  local column = math.floor((_ - 1) / column_items)\\n  local row = (_ - 1) % column_items\\n  render(item, layers[column], margin / 2 + column * column_size, row * line_size)\\nend'\n\n-- Initializes the monitor\nlocal monitor = IndustryMonitor(screens, page_size, render_script)\nsystem.print(('[ Wolfe Labs Industry Monitor XL v%s ]'):format(monitor.version))"}],"events":[],"methods":[]}